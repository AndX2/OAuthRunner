# А не послать ли нам гонца?
====
Задумываясь об авторизации в мобильном приложении одной из первых мыслей, как правило, становится вход через соцсеть. Это удобно, да и пользователи уже успели привыкнуть, что не нужно хранить пароль к каждому сервису. Поскольку данная функциональность не является ни для какого приложения ключевой было бы логичным вынести реализацию в отдельный подключаемый модуль. Итак приступим...

##Шаг первый
Для создания модуля приложения нам понадобится... приложение! Создадим новый проект в Android Studio. И, не откладывая в долгий ящик, добавим в него новый модуль: 

Структура проекта должна стать примерно такой:

Обратите внимание, что в подключаемом модуле тоже имеется манифест. При сборке приложения содержимое этого манифеста будет мержиться с главным манифестом. Для нас важно запросить здесь разрешение на использование интернета: 
```groovy
<uses-permission android:name="android.permission.INTERNET">
</uses-permission>
```
##Шаг второй
Зарегистрируем приложение, из которого мы хотели бы проходить авторизацию, на соответствующем сервисе. В моем случае это будут ВКонтакте и GitHub.

###ВКонтакте
Заходим под своим аккаунтом в [раздел создания приложений https://vk.com/apps?act=manage](https://vk.com/apps?act=manage), создаем приложение. Заходим в него, сразу открываем настройки:
Здесь важно забрать ID нашего приложения, его секретный ключ, и назначить адрес, по которому VK будет перенаправлять пользователя после авторизации. Этот параметр очень важен по двум причинам: во-первых при запросе из приложения осуществляется проверка соответствия redirectURI и, в случае несоответствия, магии не произойдет, а во-вторых ВКонтакт переправит не только самого пользователя по этому адресу но и отдаст туда в заголовке токен доступа. Хорошее решение - http://localhost, ничего из нашего устройства не уйдет.
Схема авторизации здесь очень проста: 
* открываем для пользователя страницу браузера https://oauth.vk.com/authorize с параметрами "client_id", "redirect_uri", "scope=", "VERSION_API", "response_type=token", "state"
* пользователь вводит логин/пароль
* в случае успешной валидации Вконтакте перенаправит браузер по адресу redirectUri c параметром access_token
* перехватываем запрос, забираем токен
* PROFIT

Разберем подробнее первый пункт. "client_id", "redirect_uri" - понятно из названия. VERSION_API - текущая версия 5.52, также поддерживаются более ранние версии для совместимости. Нам не надо. "scope" - права доступа приложения. Здесь лучше просмотреть [полный список](https://new.vk.com/dev/permissions). state - параметр-идентификатор будет добавлен без изменений в параметры редиректа ВКонтакте. Предназначен для определения от какого запроса мы получили токен.

###GitHub
Заходим под своим аккаунтом в настройки 

OAuth application -> Developer applications -> Register a new application

Картина такая же: ClientID, ClientSecret, RedirectURL
Схема авторизации чуть сложнее:
* открываем для пользователя страницу браузера https://github.com/login/oauth/authorize с параметром "client_id"
* в случае успешной валидации GitHub перенаправит браузер по адресу redirectUri c параметром предварительный токен
* перехватываем запрос, забираем предварительный токен
* отправляем POST запрос на https://github.com/login/oauth/access_token с параметрами "client_id", "client_secret", "grant_type=authorization_code", "redirect_uri, "code"(перехваченный предварительный токен)
* в ответ получаем access_token
* PROFIT


##Шаг третий
Техническое задание. Поскольку цель нашего проекта - подключаемый модуль, нам стоит подумать в первую очередь об удобстве его использования. Напишем себе задание:
* никаких внешних зависимостей кроме штатных возможностей SDK
* адаптация под API8...API24 без переконфигурирования
* наличие удобного фасада 
* расширяемость.

Определимся с архитектурой:
* класс-фасад, именно с ним мы будем работать в основном коде. Возврат результата выполним через кастомный интерфейс callback с двумя методами (успешной и неуспешной авторизации)
* частную реализацию для конкретных сервисов вынесем в подключаемые к фасаду плагины. Плагины будем подключать через реализуемый интерфейс. Поскольку создание и настройка плагинов будет заключаться в передаче необходимых и опциональных параметров создание из отдадим на откуп кастомному билдеру.
* ответ вернем в виде специфичного для данного плагина объекта реализующего как минимум один метод - String getAccessToken()
 
##Шаг четвертый
Каркас модуля. 
###Фасад
```java
public class Runner {
    private Context mContext;
    private Plugin mPlugin;
    private WebView mWebView;
    private Callback mCallback;
//В конструкторе передадим контекст (мало ли придется например активити запустить 
//и, разумеется, специфичный плагин по интерфейсу
public Runner(Context context, Plugin plugin) {
        this.mContext = context;
        this.mPlugin = plugin;
    }
//Интерфейс коллбека - возвращать результат
    public interface Callback {
        void onSuccess(PluginResponse response);

        void onFailure(String failureMessage);
    }
//Непосредственно работа с окном браузера
    public void execute(final Callback callback) {
    }
  
```
### Интерфейс плагина
здесь опишем методы взаимодействия фасада с подключенным плагином
```java
//Адрес для браузера
    String getUrl(); 
//Проверка, содержит ли ответ сервиса необходимые нам 
//данные токен или предварительный токен 
    boolean isContainsBody(String urlString); 
//Непосредственный запуск. Передаем строку ответа браузера и коллбек возврата результата.
    PluginResponse proceed(String response, Runner.Callback callback);

```
###Интерфейс результата
```java
public interface PluginResponse {
    String getAccessToken();
}
```

##Шаг пятый
Реализация
